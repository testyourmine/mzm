#include "types.h"
#include "gba.h"
#include "macros.h"
#include "sram/sram.h"

struct Unk_0203E000_unk84C {
    u8 pad_0[0x99A - 0x0];
    u8 unk99A[1]; // length?
};

struct Unk_0203E000 {
    u8 pad_0[0x830 - 0x0];
    s32 unk830;
    u8 pad_834[0x84C - 0x834];
    struct Unk_0203E000_unk84C *unk84C; // ptr to struct Unk_0203E000?
    u8 pad_850[0x904 - 0x850];
    s32 unk904;
};

s32 sub_0203E000(struct Unk_0203E000* arg0);
void sub_0203E118(struct Unk_0203E000* arg0);
u8* sub_0203E24C(u8* arg0);
void sub_0203E260(void);
void sub_0203E2C4(u16* dst, u8* src, s32 size);
void sub_0203E2E4(u8* dst, u8* src, s32 size);
void sub_0203E314(u8* dst, u8* src, s32 size);
u32 sub_0203E32C(u8* src1, u8* src2, s32 size);
u32 sub_0203E34C(u16* src1, u16* src2, s32 size);
s32 sub_0203E374(u32 arg0, u16* dst);
s32 sub_0203E38C(void);
s32 sub_0203E390(void);
void sub_0203E394(s32 arg0, u8* src);
void sub_0203E3A8(u8* arg0);
u8* sub_0203E3AC(u8* src);
u8* sub_0203E3DC(u8* arg0, u8* src, u8* dst);
s32 sub_0203E414(u8* src, u8* dst, u8* arg2);

const u8 sUnk_0203E43C[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const u16 sUnk_0203E44E[] = {
    0x19, 0x0A, 0x1C, 0x1C, 0x20, 0x18, 0x1B, 0x0D
};

const u16 sUnk_0203E45E[] = {
    0x19, 0x0A, 0x1C, 0x1C, 0x20, 0x18, 0x1B, 0x0D,
    0xFF, 0x19, 0x15, 0x0E, 0x0A, 0x1C, 0x0E
};

const u8 sUnk_0203E47C[] = {
    0x01, 0x20, 0x09, 0x20, 0x08, 0x20, 0x06, 0x20
};

const u16 sUnk_0203E484[] = {
    0x01, 0x09, 0x08, 0x06
};

const u8 sUnk_0203E48C[] = {
    0x8F, 0x30, 0x01, 0x20, 0x09, 0x20, 0x08, 0x20,
    0x06, 0x20, 0x3F, 0x40, 0x02, 0x20, 0x00, 0x20,
    0x00, 0x20, 0x04, 0x20, 0xFF, 0x20, 0x17, 0x30,
    0x12, 0x30, 0x17, 0x30, 0x1D, 0x30, 0x0E, 0x30,
    0x17, 0x30, 0x0D, 0x30, 0x18, 0x30
};

const u16 sUnk_0203E4B2[] = {
    0x01, 0x09, 0x08, 0x06, 0xA9, 0xAA, 0xA8, 0xA8, 0xAB
};

const u8 sUnk_0203E4C4[] = {
    0x50, 0x3A, 0x00, 0x06, 0x2D, 0x4B, 0x4D, 0x4B, 0x6D, 0x20, 0x2C, 0x4B,
    0x6D, 0x2D, 0x6C, 0x6B, 0x67, 0x66, 0x00, 0x00, 0x06, 0x3B, 0x00, 0x06, 0x68, 0x2D, 0x6C, 0x25,
    0x2D, 0x4B, 0x4D, 0x4D, 0x20, 0x4D, 0x6B, 0x4C, 0x2B, 0x4B, 0x20, 0x6D, 0x28, 0x4B, 0x20, 0x48,
    0x27, 0x4D, 0x6D, 0x00, 0x46, 0x3B, 0x00, 0x06, 0x20, 0x20, 0x20, 0x4D, 0x27, 0x26, 0x4B, 0x20,
    0x46, 0x6B, 0x48, 0x48, 0x20, 0x47, 0x4B, 0x20, 0x48, 0x6C, 0x4D, 0x6D, 0x2A, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0x50, 0x3A, 0x00, 0x06, 0x65, 0x2E, 0x6B, 0x6D, 0x20, 0x2C, 0x4B, 0x6D,
    0x2D, 0x6C, 0x6B, 0x67, 0x66, 0x00, 0x00, 0x00, 0x06, 0x3B, 0x00, 0x06, 0x68, 0x2D, 0x6C, 0x25,
    0x2D, 0x4B, 0x4D, 0x4D, 0x20, 0x4D, 0x6B, 0x4C, 0x2B, 0x4B, 0x20, 0x6D, 0x28, 0x4B, 0x20, 0x48,
    0x27, 0x4D, 0x6D, 0x00, 0x46, 0x3B, 0x00, 0x06, 0x20, 0x20, 0x20, 0x4D, 0x27, 0x26, 0x4B, 0x20,
    0x46, 0x6B, 0x48, 0x48, 0x20, 0x47, 0x4B, 0x20, 0x48, 0x6C, 0x4D, 0x6D, 0x2A, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xD4, 0x3B, 0x00, 0x06, 0x03, 0x20, 0x29, 0x4B, 0x4D, 0x20, 0x20, 0x02,
    0x05, 0x4C, 0x6C, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xD4, 0x3B, 0x00, 0x06, 0x05, 0x29, 0x4B, 0x4D,
    0x20, 0x20, 0x20, 0x03, 0x4C, 0x6C, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0C, 0x3B, 0x00, 0x06,
    0x4D, 0x27, 0x26, 0x4B, 0x20, 0x29, 0x6C, 0x2E, 0x2D, 0x20, 0x68, 0x2D, 0x6C, 0x25, 0x2D, 0x4B,
    0x4D, 0x4D, 0x00, 0x00, 0x4C, 0x3B, 0x00, 0x06, 0x20, 0x20, 0x6D, 0x6C, 0x20, 0x6D, 0x28, 0x4B,
    0x20, 0x2C, 0x4B, 0x2C, 0x6C, 0x2D, 0x29, 0x66, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x3B, 0x00, 0x06,
    0x68, 0x2D, 0x4B, 0x26, 0x6B, 0x6C, 0x2E, 0x4D, 0x20, 0x67, 0x27, 0x6D, 0x27, 0x20, 0x46, 0x6B,
    0x48, 0x48, 0x00, 0x00, 0x0C, 0x3C, 0x00, 0x06, 0x20, 0x20, 0x47, 0x4B, 0x20, 0x6C, 0x26, 0x4B,
    0x2D, 0x46, 0x2D, 0x6B, 0x6D, 0x6D, 0x4B, 0x4C, 0x2A, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    0x94, 0x3C, 0x00, 0x06, 0x03, 0x20, 0x29, 0x4B, 0x4D, 0x20, 0x20, 0x02, 0x05, 0x4C, 0x6C, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0x94, 0x3C, 0x00, 0x06, 0x05, 0x29, 0x4B, 0x4D, 0x20, 0x20, 0x20, 0x03,
    0x4C, 0x6C, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x8C, 0x3B, 0x00, 0x06, 0x2B, 0x6C, 0x4C, 0x6D,
    0x6B, 0x4C, 0x2E, 0x4B, 0x20, 0x68, 0x48, 0x27, 0x29, 0x6B, 0x4C, 0x25, 0x66, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF
};

const u8 sUnk_0203E634[] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEE, 0xFF, 0xFF, 0xFF, 0xEE, 0xFE, 0xFF,
    0xFF, 0xEE, 0xEE, 0xFF, 0xFF, 0xEE, 0xFE, 0xFF, 0xFF, 0xEE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFE, 0xFF, 0xFF, 0xEF, 0xEE, 0xFF, 0xFF,
    0xEF, 0xEE, 0xFE, 0xFF, 0xEF, 0xEE, 0xFF, 0xFF, 0xEF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEE, 0xFF, 0xFF, 0xFF, 0xEE, 0xFE, 0xFF, 0xFF,
    0xEE, 0xEE, 0xFF, 0xFF, 0xEE, 0xFE, 0xFF, 0xFF, 0xEE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEE, 0xFF, 0xFF, 0xFF, 0xEE, 0xFE, 0xFF, 0xFF,
    0xEE, 0xEE, 0xFF, 0xFF, 0xEE, 0xFE, 0xFF, 0xFF, 0xEE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFE, 0xFF, 0xFF, 0xEF, 0xEE, 0xFF, 0xFF,
    0xEF, 0xEE, 0xFE, 0xFF, 0xEF, 0xEE, 0xFF, 0xFF, 0xEF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEE, 0xFF, 0xFF, 0xFF, 0xEE, 0xFE, 0xFF,
    0xFF, 0xEE, 0xEE, 0xFF, 0xFF, 0xEE, 0xFE, 0xFF, 0xFF, 0xEE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF
};

s32 sub_0203E000(struct Unk_0203E000* arg0)
{
    s32 var_r4;
    u32 var_r5;
    u32 temp_r3;
    u8* unk_06002000;
    s32 var_0;
    u8 subroutine_arg0[0x14];

    unk_06002000 = (u8*)0x06002000;
    if (sub_0203E34C((void*)unk_06002000 + 0x298, (u16*)sUnk_0203E44E, sizeof(sUnk_0203E44E)) != 0)
    {
        arg0->unk904 &= ~4;
        if (arg0->unk830 == 0x30)
        {
            arg0->unk830 = 0;
        }
        return 0;
    }

    if (arg0->unk904 & 4)
        return 0;

    arg0->unk830 = 0x30;
    if (!(READ_16(REG_DISPCNT) & DCNT_BG3))
        return 0;

    var_0 = 0;
    var_r4 = 0;
    for (var_r5 = 0; var_r5 < 0x18; var_r5++)
    {
        temp_r3 = unk_06002000[0x6A4/2 + (var_r4 * 2)];

        var_r4 += 1;
        if (var_r4 == 6 || var_r4 == 0x46)
        {
            var_r4 += 1;
        }
        else if (var_r4 == 0xD)
        {
            var_r4 = 0x40;
        }

        if (temp_r3 >= 0x40)
            return 0;

        switch (var_r5 & 3)
        {
            case 0:
                subroutine_arg0[var_0] = temp_r3;
                break;

            case 1:
                subroutine_arg0[var_0] |= temp_r3 << 6;
                var_0++;
                subroutine_arg0[var_0] = temp_r3 >> 2;
                break;

            case 2:
                subroutine_arg0[var_0] |= temp_r3 << 4;
                var_0++;
                subroutine_arg0[var_0] = temp_r3 >> 4;
                break;

            case 3:
                subroutine_arg0[var_0] |= temp_r3 << 2;
                var_0++;
                break;
        }
    }

    sub_0203E314((u8*)sUnk_0203E43C, subroutine_arg0, sizeof(sUnk_0203E43C));
    arg0->unk904 |= 4;
    return 1;
}

void sub_0203E118(struct Unk_0203E000* arg0)
{
    s32 var_r5;
    s32 var_r3;
    u32 var_r4;
    u32 var_r6;
    u16* unk_06002000;

    unk_06002000 = (u16*)0x06002000;
    if (sub_0203E34C((void*)unk_06002000 + 0x150, (u16*)sUnk_0203E45E, sizeof(sUnk_0203E45E)) != 0)
    {
        if (arg0->unk830 == 0x18)
        {
            arg0->unk830 = 0;
        }
        return;
    }

    for (var_r6 = 0; var_r6 < 13; var_r6 += 1)
    {
        if ((unk_06002000[0x212/2 + var_r6] & 0xFF) < 0x40)
            return;

        if ((unk_06002000[0x292/2 + var_r6] & 0xFF) < 0x40)
            return;
    }

    arg0->unk830 = 0x18;
    for (var_r6 = 0; var_r6 < sizeof(sUnk_0203E43C); var_r6++)
    {
        if (sUnk_0203E43C[var_r6] != 0)
            break;
    }

    if (var_r6 == 0x12)
        return;

    var_r3 = 0;
    var_r5 = 0;
    for (var_r6 = 0; var_r6 < 0x18; var_r6++)
    {
        switch (var_r6 & 3)
        {
            case 0:
                var_r4 = sUnk_0203E43C[var_r3];
                var_r3++;
                break;

            case 1:
                var_r4 = (var_r4 >> 6) | (sUnk_0203E43C[var_r3] << 2);
                var_r3++;
                break;

            case 2:
                var_r4 = (var_r4 >> 6) | (sUnk_0203E43C[var_r3] << 4);
                var_r3++;
                break;

            case 3:
                var_r4 = var_r4 >> 6;
                break;
        }

        var_r6[arg0->unk84C->unk99A] = var_r4 & 0x3F;
        unk_06002000[0x212/2 + var_r5] = (var_r4 & 0x3F) | 0x1000;

        var_r5 += 1;
        if (var_r5 == 0x6 || var_r5 == 0x46)
        {
            var_r5 += 1;
        }
        else if (var_r5 == 0xD)
        {
            var_r5 = 0x40;
        }
    }
}

u8* sub_0203E24C(u8* arg0)
{
    sub_0203E394(0, arg0);
    return arg0;
}

void sub_0203E260(void)
{
    u16* unk_06002000;

    unk_06002000 = (u16*)0x06002000;
    if (sub_0203E34C(unk_06002000 + 0x4D6/2, (u16*)sUnk_0203E47C, sizeof(sUnk_0203E47C)) == 0)
    {
        sub_0203E2C4(unk_06002000 + 0x4CE/2, (u8*)sUnk_0203E48C, sizeof(sUnk_0203E48C));
    }
    else if (sub_0203E34C(unk_06002000 + 0x71C/2, (u16*)sUnk_0203E484, sizeof(sUnk_0203E484)) == 0)
    {
        sub_0203E2C4(unk_06002000 + 0x716/2, (u8*)sUnk_0203E4B2, sizeof(sUnk_0203E4B2));
    }
}

void sub_0203E2C4(u16* dst, u8* src, s32 size)
{
    void* end;

    end = src + size;
    do
    {
        *dst++ = src[0] | (src[1] << 8);
        src += 2;
    }
    while ((u32)src < (u32)end);
}

void sub_0203E2E4(u8* dst, u8* src, s32 size)
{
    u32 var_r2;
    void* end;

    end = src + size;
    do
    {
        if ((u32)src & 1)
        {
            var_r2 = *(u16*)(src - 1) >> 8;
        }
        else
        {
            var_r2 = *(u16*)src & 0xFF;
        }
        *dst++ = var_r2;
        src += 1;
    }
    while ((u32)src < (u32)end);
}

void sub_0203E314(u8* dst, u8* src, s32 size)
{
    void* end;

    end = src + size;
    do
    {
        *dst++ = *src++;
    }
    while ((u32)src < (u32)end);
}

u32 sub_0203E32C(u8* src1, u8* src2, s32 size)
{
    u32 temp_r0;

    do
    {
        temp_r0 = *src1++ - *src2++;
        size -= 1;
    }
    while (temp_r0 == 0 && size != 0);

    return temp_r0;
}

u32 sub_0203E34C(u16* src1, u16* src2, s32 size)
{
    u32 temp_r0;

    do
    {
    }
    while (size & 1);

    do
    {
        temp_r0 = *src1++ - *src2++;
        size -= 2;
    }
    while (temp_r0 == 0 && size != 0);

    return temp_r0;
}

s32 sub_0203E374(u32 arg0, u16* dst)
{
    sub_0203E2C4(dst, (u8*)sUnk_0203E43C, sizeof(sUnk_0203E43C));
    return 0x18;
}

s32 sub_0203E38C(void)
{
    return 0;
}

s32 sub_0203E390(void)
{
    return 0;
}

void sub_0203E394(s32 arg0, u8* src)
{
    sub_0203E314((u8*)sUnk_0203E43C, src + 0x10, sizeof(sUnk_0203E43C));
}

void sub_0203E3A8(u8* arg0)
{
    return;
}

u8* sub_0203E3AC(u8* src)
{
    u8* ret;

    sub_0203E3A8(src);
    ret = SramWriteChecked(src, SRAM_BASE + 0x7FB0, 0x10);
    if (ret == 0)
    {
        ret = SramWriteChecked(src, SRAM_BASE + 0x7FD8, 0x10);
    }
    return ret;
}

u8* sub_0203E3DC(u8* arg0, u8* src, u8* dst)
{
    u8* ret;

    sub_0203E3A8(arg0);
    if (dst == NULL)
    {
        dst = SRAM_BASE + 0x7FB0;
    }

    ret = SramWriteChecked(src + 0x10, dst + 0x10, 0x18);
    if (ret == 0)
    {
        ret = SramWriteChecked(src, dst, 0x10);
    }
    return ret;
}

s32 sub_0203E414(u8* src, u8* dst, u8* arg2)
{
    sub_0203E3A8(arg2);
    if (src == NULL)
    {
        src = SRAM_BASE + 0x7FB0;
    }

    SramWriteUnchecked(src, dst, 0x28);
    return 0x28;
}
